<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:math="http://www.w3.org/1998/Math/MathML" 
  xmlns:rng="http://relaxng.org/ns/structure/1.0"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xpr="xpr"
  xmlns:eg="http://www.tei-c.org/ns/Examples">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Title</title>
      </titleStmt>
      <publicationStmt>
        <p>Publication Information</p>
      </publicationStmt>
      <sourceDesc>
        <p>Information about the source</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <schemaSpec ident="xprOdd" start="expertise" ns="xpr">
        
        <elementSpec ident="address">
          <gloss>Address</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="street"/>
              <elementRef key="buildingNumber"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="agent">
          <!-- from EAC -->
          <gloss>Agent</gloss>
          <desc>The agent (human or machine) responsible for an event in the maintenance of the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="agentType">
          <!-- from EAC -->
          <gloss>Agent Type</gloss>
          <desc>Type of agent responsible for a maintenance event of the expertise instance</desc>
          <content>
            <alternate>
              <textNode/>
            </alternate>
          </content>
          <constraintSpec scheme="schematron" ident="agentTypeValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:agentType">
                <sch:assert test="normalize-space(.) = 'human' or normalize-space(.) = 'machine'">La valeur de l'élément agentType doit correspondre à "human" ou "machine".</sch:assert>
              </sch:rule>
            </constraint>  
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="appendice">
          <gloss>Appendice</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="type" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="extent"/>
              <elementRef key="desc"/>
              <elementRef key="note"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="appendices">
          <gloss>Appendices</gloss>
          <desc></desc>
          <content>
            <elementRef key="appendice" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        
        <elementSpec ident="buildingNumber">
          <gloss>Building Number</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="category">
          <!-- @todo schematron correspondance valeur de l'élément et de l'attribut -->
          <gloss>Category</gloss>
          <desc></desc>
          <content>
            <textNode/>
            <!--<valList>
              <valItem ident="Décrire et évaluer les travaux à venir"/>
              <valItem ident="Départager"/>
              <valItem ident="Enregistrer"/>
              <valItem ident="Estimer la valeur des biens"/>
              <valItem ident="Recevoir et évaluer le travail réalisé"/>
            </valList>-->
          </content>
          <constraintSpec scheme="schematron" ident="categoryValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:category">
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="type" value="@type"/>
                <sch:let name="value">
                  <xsl:choose>
                    <xsl:when test="$type = 'assessment'"><xsl:text>Décrire et évaluer les travaux à venir</xsl:text></xsl:when>
                    <xsl:when test="$type = 'settlement'"><xsl:text>Départager</xsl:text></xsl:when>
                    <xsl:when test="$type = 'registration'"><xsl:text>Enregistrer</xsl:text></xsl:when>
                    <xsl:when test="$type = 'estimation'"><xsl:text>Estimer la valeur des biens</xsl:text></xsl:when>
                    <xsl:when test="$type = 'acceptation'"><xsl:text>Recevoir et évaluer le travail réalisé</xsl:text></xsl:when>
                    <xsl:otherwise/>
                  </xsl:choose>
                </sch:let>
                <sch:assert test="$content = $value">La valeur de l'élément category doit correspondre à "<sch:value-of select="$value"/>".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="assessment"/>
                <valItem ident="settlement"/>
                <valItem ident="registration"/>
                <valItem ident="estimation"/>
                <valItem ident="acceptation"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="categories">
          <gloss>Categories</gloss>
          <desc></desc>
          <content>
            <sequence>
              <!-- @rmq un ou plus (category) -->
              <elementRef key="category"/>
              <elementRef key="designation"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="city">
          <gloss>City</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="complement">
          <gloss>Complement</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="control">
          <!-- from EAC -->
          <gloss>Control</gloss>
          <desc>The element of the instance that contains control information about its identity, creation, maintenance, status, and the rules and authorities used in the composition of the description.</desc>
          <content>
            <sequence>
              <elementRef key="maintenanceStatus"/>
              <elementRef key="publicationStatus"/>
              <elementRef key="localControl"/>
              <elementRef key="maintenanceHistory"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="date">
          <gloss>Date</gloss>
          <desc></desc>
          <content>
            <empty/>
          </content>
          <attList>
            <attDef ident="when" usage="req">
              <datatype>
                <dataRef name="date"/>
              </datatype>
            </attDef>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="paris"/>
                <valItem ident="suburbs"/>
                <valItem ident="province"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="description">
          <gloss>Description</gloss>
          <desc>Description related to the described expertise.</desc>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="sessions"/>
              <elementRef key="places"/>
              <elementRef key="categories"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="desc">
          <gloss>Description</gloss>
          <desc>Description related to an appendice.</desc>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="designation">
          <gloss>Designation</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <attList>
            <attDef ident="rubric" usage="req">
              <valList type="closed">
                <valItem ident="true"/>
                <valItem ident="false"/>
              </valList>
            </attDef>  
          </attList>
        </elementSpec>
        
        <elementSpec ident="district">
          <gloss>District</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="expertise" module="xpr">
          <gloss>Expertise</gloss>
          <desc>Contains the entire description of an expertise.</desc>
          <content>
            <sequence>
              <elementRef key="meta"/>
              <elementRef key="control"/>
              <elementRef key="sourceDesc"/>
              <elementRef key="description"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="status">
              <!-- @quest à maintenir ? je ne crois pas que nous avions défini de valeur -->
              <datatype>
                <dataRef key="teidata.text"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="eventDateTime">
          <!-- from EAC -->
          <gloss>Maintenance Event Date and Time</gloss>
          <desc>The date and time of a maintenance event for the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
          <attList>
            <attDef ident="standardDateTime">
              <datatype>
                <!-- @rmq ne fonctionne pas !? -->
                <dataRef key="teidata.temporal.w3c"/>
                <!--<dataRef name="dateTime"/>-->
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="eventType">
          <gloss>Maintenance Event Type</gloss>
          <desc>The type of maintenance event for the EAC-CPF instance.</desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="eventType" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:eventType">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="value" value="('cancelled', 'created', 'deleted', 'derived', 'revised', 'updated')"/>
                <sch:assert test="$content = $value">La valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à : <sch:value-of select="string-join($value, ', ')"/></sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="eventDescription">
          <!-- from EAC -->
          <gloss>Maintenance Event Description</gloss>
          <desc>The description of a maintenance event in the life of the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="extent">
          <!-- @todo schematron pour @sketch si physDesc/extent -->
          <gloss>Extent</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="extentContent" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:extent">
                <sch:assert test="number(.) castable as xs:integer">Le contenu de l'élément &lt;extent&gt; doit être un nombre.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="sketch" usage="opt">
              <valList type="closed">
                <valItem ident="true"/>
                <valItem ident="false"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="facsimile">
          <gloss>Facsimile</gloss>
          <desc></desc>
          <content>
            <empty/>
          </content>
          <attList>
            <attDef ident="from" usage="req">
              <gloss>From</gloss>
              <desc></desc>
              <datatype>
                <dataRef name="integer"/>
              </datatype>
            </attDef>
            <attDef ident="to" usage="req">
              <gloss>To</gloss>
              <desc></desc>
              <datatype>
                <dataRef name="integer"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="idno" ns="xpr">
          <gloss>Identifier</gloss>
          <desc></desc>
          <constraintSpec ident="idnoType" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:sourceDesc[count(xpr:idno) = 2]">
                <sch:assert test="xpr:idno[1][@type='unitid']">Le premier idno doit être de type 'unitid'</sch:assert>
                <sch:assert test="xpr:idno[2][@type='item']">Le second idno doit être de type 'item'</sch:assert>
              </sch:rule>
              <sch:rule context="xpr:sourceDesc[count(xpr:idno) = 3]">
                <sch:assert test="xpr:idno[1][@type='unitid']">Le premier idno doit être de type 'unitid'</sch:assert>
                <sch:assert test="xpr:idno[2][@type='item']">Le second idno doit être de type 'item'</sch:assert>
                <sch:assert test="xpr:idno[3][@type='supplement']">Le troisième idno doit être de type 'supplement'</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="unitid"/>
                <valItem ident="item"/>
                <valItem ident="supplement"></valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="localControl">
          <!-- from EAC -->
          <gloss>Local Control</gloss>
          <desc>Any additional control entry necessary to accommodate local practice.</desc>
          <content>
            <elementRef key="term"/>
          </content>
          <attList>
            <attDef ident="localType">
              <valList type="closed">
                <valItem ident="detailLevel"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="maintenanceEvent">
          <!-- from EAC -->
          <gloss>Maintenance Event</gloss>
          <desc>A maintenance event in the life of the expertise instance.</desc>
          <content>
            <sequence>
              <elementRef key="eventType"/>
              <elementRef key="eventDateTime"/>
              <elementRef key="agentType"/>
              <elementRef key="agent"/>
              <elementRef key="eventDescription"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="maintenanceHistory">
          <!-- from EAC -->
          <gloss>Maintenance History</gloss>
          <desc>The history of the creation and maintenance of the expertise instance.</desc>
          <content>
            <sequence>
              <elementRef key="maintenanceEvent" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="maintenanceStatus">
          <!-- from EAC -->
          <gloss>Maintenance Status</gloss>
          <desc>The current drafting status of the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="maintenanceStatusValues" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:maintenanceStatus">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="value" value="('inProcess', 'approved')"/>
                  <sch:assert test="$content = $value">La valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à : <sch:value-of select="string-join($value, ', ')"/></sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="meta">
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="note">
          <gloss>Note</gloss>
          <desc>Note related to an appendice.</desc>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="owner">
          <gloss>Owner</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="parish">
          <gloss>Parish</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="physDesc">
          <gloss>Physical Description</gloss>
          <desc>Physical description of the expertise</desc>
          <content>
            <sequence>
              <elementRef key="extent"/>
              <elementRef key="appendices"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="place">
          <gloss>Place</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="address"/>
              <elementRef key="complement"/>
              <elementRef key="parish"/>
              <elementRef key="city"/>
              <elementRef key="district"/>
              <elementRef key="owner" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="type">
              <valList type="closed">
                <valItem ident="paris"/>
                <valItem ident="suburbs"/>
                <valItem ident="province"/>
                <valItem ident="office"/>
                <valItem ident="clerkOffice"/>
                <valItem ident="indeterminate"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="places">
          <gloss>Places</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="place" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="publicationStatus">
          <!-- from EAC -->
          <gloss>Publication Status</gloss>
          <desc>The current publication status of the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="publicationStatusValues" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:publicationStatus">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="value" value="('inProcess', 'approved')"/>
                <sch:assert test="$content = $value">La valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à : <sch:value-of select="string-join($value, ', ')"/></sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="sessions">
          <gloss>Sessions</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="date"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="sourceDesc">
          <gloss>Source Description</gloss>
          <desc>Contains bibliographic and physical description of an expertise.</desc>
          <content>
            <sequence>
              <elementRef key="idno" minOccurs="2" maxOccurs="3"/>
              <elementRef key="facsimile"/>
              <elementRef key="physDesc"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="street">
          <gloss>Street</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="term">
          <!-- from EAC -->
          <gloss>Term</gloss>
          <desc>A generic element used to encode a descriptive term in accordance with local descriptive rules.</desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="type">
          <gloss>Type</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="drawing"/>
                <valItem ident="plan"/>
                <valItem ident="sketch"/>
                <valItem ident="rough"/>
                <valItem ident="proxyPA"/>
                <valItem ident="proxyNa"/>
                <valItem ident="petition"/>
                <valItem ident="other"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
      </schemaSpec>
    </body>
  </text>
</TEI>
