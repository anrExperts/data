<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xs="http://www.w3.org/2001/XMLSchema" 
  xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:math="http://www.w3.org/1998/Math/MathML" 
  xmlns:rng="http://relaxng.org/ns/structure/1.0"
  xmlns:sch="http://purl.oclc.org/dsdl/schematron"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xpr="xpr"
  xmlns:eg="http://www.tei-c.org/ns/Examples">
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Title</title>
      </titleStmt>
      <publicationStmt>
        <p>Publication Information</p>
      </publicationStmt>
      <sourceDesc>
        <p>Information about the source</p>
      </sourceDesc>
    </fileDesc>
  </teiHeader>
  <text>
    <body>
      <schemaSpec ident="xprOdd" start="expertise" ns="xpr">
        
        <elementSpec ident="address">
          <gloss>Address</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="street"/>
              <elementRef key="buildingNumber"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="agent">
          <!-- from EAC -->
          <gloss>Agent</gloss>
          <desc>The agent (human or machine) responsible for an event in the maintenance of the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="agentType">
          <!-- from EAC -->
          <gloss>Agent Type</gloss>
          <desc>Type of agent responsible for a maintenance event of the expertise instance</desc>
          <content>
            <alternate>
              <textNode/>
            </alternate>
          </content>
          <constraintSpec scheme="schematron" ident="agentTypeValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:agentType">
                <sch:assert test="normalize-space(.) = 'human' or normalize-space(.) = 'machine'">La valeur de l'élément agentType doit correspondre à "human" ou "machine".</sch:assert>
              </sch:rule>
            </constraint>  
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="appendice">
          <gloss>Appendice</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="type" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="extent"/>
              <elementRef key="desc"/>
              <elementRef key="note"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="appendices">
          <gloss>Appendices</gloss>
          <desc></desc>
          <content>
            <elementRef key="appendice" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        
        <elementSpec ident="buildingNumber">
          <gloss>Building Number</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="case">
          <gloss>Case</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="category">
          <gloss>Category</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec scheme="schematron" ident="categoryValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:category">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="type" value="@type"/>
                <sch:let name="value">
                  <xsl:choose>
                    <xsl:when test="$type = 'assessment'"><xsl:text>Décrire et évaluer les travaux à venir</xsl:text></xsl:when>
                    <xsl:when test="$type = 'settlement'"><xsl:text>Départager</xsl:text></xsl:when>
                    <xsl:when test="$type = 'registration'"><xsl:text>Enregistrer</xsl:text></xsl:when>
                    <xsl:when test="$type = 'estimation'"><xsl:text>Estimer la valeur des biens</xsl:text></xsl:when>
                    <xsl:when test="$type = 'acceptation'"><xsl:text>Recevoir et évaluer le travail réalisé</xsl:text></xsl:when>
                    <xsl:otherwise/>
                  </xsl:choose>
                </sch:let>
                <sch:assert test="$content = $value">Compte tenu du type sélectionné (<sch:value-of select="$type"/>), la valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à "<sch:value-of select="$value"/>".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="assessment"/>
                <valItem ident="settlement"/>
                <valItem ident="registration"/>
                <valItem ident="estimation"/>
                <valItem ident="acceptation"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="categories">
          <gloss>Categories</gloss>
          <desc></desc>
          <content>
            <sequence>
              <!-- @rmq un ou plus (category) -->
              <elementRef key="category"/>
              <elementRef key="designation"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="city">
          <gloss>City</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="clerk">
          <gloss>Clerk</gloss>
          <desc></desc>
          <classes>
            <memberOf key="att.pointer"/>
          </classes>
          <content>
            <sequence>
              <elementRef key="persName"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="clerks">
          <gloss>Clerks</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="clerk" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="complement">
          <gloss>Complement</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="conclusions">
          <gloss>Conclusions</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="agreement"/>
              <elementRef key="opinion" minOccurs="0" maxOccurs="unbounded"/>
              <elementRef key="arrangement"/>
              <elementRef key="estimate"/>
              <elementRef key="fees"/>
              <elementRef key="expenses"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="control">
          <!-- from EAC -->
          <gloss>Control</gloss>
          <desc>The element of the instance that contains control information about its identity, creation, maintenance, status, and the rules and authorities used in the composition of the description.</desc>
          <content>
            <sequence>
              <elementRef key="maintenanceStatus"/>
              <elementRef key="publicationStatus"/>
              <elementRef key="localControl"/>
              <elementRef key="maintenanceHistory"/>
            </sequence>
          </content>
        </elementSpec>

        <elementSpec ident="craftman">
          <gloss>Craftman</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="persName"/>
              <elementRef key="occupation"/>
            </sequence>
          </content>
        </elementSpec>

        <elementSpec ident="craftmen">
          <gloss>Craftmen</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="craftman" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="date">
          <gloss>Date</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec scheme="schematron" ident="dateValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:date[parent::xpr:sessions]">
                <sch:let name="node" value="local-name()"/>
                <sch:assert test="@type and .=''">Aucun contenu autorisé au sein de l'élément &lt;<sch:value-of select="$node"/>&gt;.</sch:assert>
              </sch:rule>
              <sch:rule context="xpr:date[parent::xpr:sentence]">
                <sch:let name="node" value="local-name()"/>
                <sch:assert test="not(@type)">l'attribut @type n'est pas autorisé dans ce contexte .</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="when" usage="req">
              <datatype>
                <dataRef name="date"/>
              </datatype>
            </attDef>
            <attDef ident="type" usage="opt">
              <valList type="closed">
                <valItem ident="paris"/>
                <valItem ident="suburbs"/>
                <valItem ident="province"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="description">
          <gloss>Description</gloss>
          <desc>Description related to the described expertise.</desc>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="sessions"/>
              <elementRef key="places"/>
              <elementRef key="categories"/>
              <elementRef key="procedure"/>
              <elementRef key="participants"/>
              <elementRef key="conclusions"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="desc">
          <gloss>Description</gloss>
          <desc>Description related to an appendice.</desc>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="designation">
          <gloss>Designation</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <attList>
            <attDef ident="rubric" usage="req">
              <valList type="closed">
                <valItem ident="true"/>
                <valItem ident="false"/>
              </valList>
            </attDef>  
          </attList>
        </elementSpec>
        
        <elementSpec ident="district">
          <gloss>District</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="eventDateTime">
          <!-- from EAC -->
          <gloss>Maintenance Event Date and Time</gloss>
          <desc>The date and time of a maintenance event for the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
          <attList>
            <attDef ident="standardDateTime">
              <datatype>
                <!-- @rmq ne fonctionne pas !? -->
                <dataRef key="teidata.temporal.w3c"/>
                <!--<dataRef name="dateTime"/>-->
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="eventType">
          <gloss>Maintenance Event Type</gloss>
          <desc>The type of maintenance event for the EAC-CPF instance.</desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="eventType" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:eventType">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="value" value="('cancelled', 'created', 'deleted', 'derived', 'revised', 'updated')"/>
                <sch:assert test="$content = $value">La valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à : <sch:value-of select="string-join($value, ', ')"/></sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="eventDescription">
          <!-- from EAC -->
          <gloss>Maintenance Event Description</gloss>
          <desc>The description of a maintenance event in the life of the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="expert">
          <gloss>Expert</gloss>
          <desc></desc>
          <classes>
            <memberOf key="att.pointer"/>
          </classes>
          <content>
            <alternate minOccurs="0" maxOccurs="1">
              <empty/>
              <elementRef key="title"/>  
            </alternate>
          </content>
          <constraintSpec scheme="schematron" ident="expertAttr">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:expert[parent::xpr:experts]">
                <sch:let name="node" value="local-name()"/>
                <sch:assert test="@context">Attribut @context manquant.</sch:assert>
                <sch:assert test="@appointment">Attribut @appointment manquant.</sch:assert>
                <sch:assert test="xpr:title">Élément &lt;title&gt; manquant.</sch:assert>
              </sch:rule>
              <sch:rule context="xpr:expert[parent::xpr:party]">
                <sch:let name="node" value="local-name()"/>
                <sch:assert test="not(@context)">Attribut @context non autorisé dans ce contexte.</sch:assert>
                <sch:assert test="not(@appointment)">Attribut @appointment non autorisé dans ce contexte.</sch:assert>
                <sch:assert test="not(xpr:title)">Élément &lt;title&gt; non autorisé dans ce contexte.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="context" usage="opt">
              <gloss>Context</gloss>
              <desc>Qualité de l’expert</desc>
              <valList type="closed">
                <valItem ident="primary">
                  <gloss>primary</gloss>
                  <desc>premier lieu</desc>
                </valItem>
                <valItem ident="third-party">
                  <gloss>third-party</gloss>
                  <desc>tiers expert</desc>
                </valItem>
                <valItem ident="unknown">
                  <gloss>unknown</gloss>
                  <desc>indéterminé</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="appointment" usage="opt">
              <gloss>Appointment</gloss>
              <desc>Origine de la nomination</desc>
              <valList type="closed">
                <valItem ident="court-appointed">
                  <gloss>court-appointed</gloss>
                  <desc>d’office (par une institution)</desc>
                </valItem>
                <valItem ident="appointed">
                  <gloss>appointed</gloss>
                  <desc>par les parties</desc>
                </valItem>
                <valItem ident="experts">
                  <gloss>experts</gloss>
                  <desc>par les experts</desc>
                </valItem>
                <valItem ident="mixed">
                  <gloss>mixed</gloss>
                  <desc>mixte</desc>
                </valItem>
                <valItem ident="unknown">
                  <gloss>unknown</gloss>
                  <desc>indéterminé</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="expertise" module="xpr">
          <gloss>Expertise</gloss>
          <desc>Contains the entire description of an expertise.</desc>
          <classes>
            <memberOf key="att.global"/>
          </classes>
          <content>
            <sequence>
              <elementRef key="meta"/>
              <elementRef key="control"/>
              <elementRef key="sourceDesc"/>
              <elementRef key="description"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="status">
              <!-- @quest à maintenir ? je ne crois pas que nous avions défini de valeur -->
              <datatype>
                <dataRef key="teidata.text"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="experts">
          <gloss>Experts</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="expert" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="extent">
          <!-- @todo schematron pour @sketch si physDesc/extent -->
          <gloss>Extent</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="extentContent" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:extent">
                <sch:assert test="number(.) castable as xs:integer">Le contenu de l'élément &lt;extent&gt; doit être un nombre.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="sketch" usage="opt">
              <valList type="closed">
                <valItem ident="true"/>
                <valItem ident="false"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="facsimile">
          <gloss>Facsimile</gloss>
          <desc></desc>
          <content>
            <empty/>
          </content>
          <attList>
            <attDef ident="from" usage="req">
              <gloss>From</gloss>
              <desc></desc>
              <datatype>
                <dataRef name="integer"/>
              </datatype>
            </attDef>
            <attDef ident="to" usage="req">
              <gloss>To</gloss>
              <desc></desc>
              <datatype>
                <dataRef name="integer"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="forename">
          <gloss>Forename</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="framework">
          <gloss>Cadre de l'expertise</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec scheme="schematron" ident="frameworkValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:framework">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="type" value="@type"/>
                <sch:let name="value">
                  <xsl:choose>
                    <xsl:when test="$type = 'a'"><xsl:text>Commun accord des parties</xsl:text></xsl:when>
                    <xsl:when test="$type = 'b1'"><xsl:text>Requête auprès d’une institution pour qu’elle demande une expertise</xsl:text></xsl:when>
                    <xsl:when test="$type = 'b2'"><xsl:text>L’institution est saisie dans le cadre d’une procédure (les parties nomment chacune leur expert ou un expert en commun)</xsl:text></xsl:when>
                    <xsl:when test="$type = 'c'"><xsl:text>Cas problématique</xsl:text></xsl:when>
                    <xsl:otherwise/>
                  </xsl:choose>
                </sch:let>
                <sch:assert test="$content = $value">Compte tenu du type sélectionné (<sch:value-of select="$type"/>), la valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à "<sch:value-of select="$value"/>".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type">
              <valList type="closed">
                <valItem ident="a"/>
                <valItem ident="b1"/>
                <valItem ident="b2"/>
                <valItem ident="c"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="idno" ns="xpr">
          <gloss>Identifier</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="idnoType" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:sourceDesc[count(xpr:idno) = 2]">
                <sch:assert test="xpr:idno[1][@type='unitid']">Le premier idno doit être de type 'unitid'</sch:assert>
                <sch:assert test="xpr:idno[2][@type='item']">Le second idno doit être de type 'item'</sch:assert>
              </sch:rule>
              <sch:rule context="xpr:sourceDesc[count(xpr:idno) = 3]">
                <sch:assert test="xpr:idno[1][@type='unitid']">Le premier idno doit être de type 'unitid'</sch:assert>
                <sch:assert test="xpr:idno[2][@type='item']">Le second idno doit être de type 'item'</sch:assert>
                <sch:assert test="xpr:idno[3][@type='supplement']">Le troisième idno doit être de type 'supplement'</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="unitid"/>
                <valItem ident="item"/>
                <valItem ident="supplement"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="localControl">
          <!-- from EAC -->
          <gloss>Local Control</gloss>
          <desc>Any additional control entry necessary to accommodate local practice.</desc>
          <content>
            <elementRef key="term"/>
          </content>
          <attList>
            <attDef ident="localType">
              <valList type="closed">
                <valItem ident="detailLevel"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="maintenanceEvent">
          <!-- from EAC -->
          <gloss>Maintenance Event</gloss>
          <desc>A maintenance event in the life of the expertise instance.</desc>
          <content>
            <sequence>
              <elementRef key="eventType"/>
              <elementRef key="eventDateTime"/>
              <elementRef key="agentType"/>
              <elementRef key="agent"/>
              <elementRef key="eventDescription"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="maintenanceHistory">
          <!-- from EAC -->
          <gloss>Maintenance History</gloss>
          <desc>The history of the creation and maintenance of the expertise instance.</desc>
          <content>
            <sequence>
              <elementRef key="maintenanceEvent" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="maintenanceStatus">
          <!-- from EAC -->
          <gloss>Maintenance Status</gloss>
          <desc>The current drafting status of the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="maintenanceStatusValues" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:maintenanceStatus">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="value" value="('new', 'revised')"/>
                  <sch:assert test="$content = $value">La valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à : <sch:value-of select="string-join($value, ', ')"/></sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="meta">
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="note">
          <gloss>Note</gloss>
          <desc>Note related to an appendice.</desc>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="object">
          <gloss>Object</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec scheme="schematron" ident="objectValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:object[@type!='other']">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="type" value="@type"/>
                <sch:let name="value">
                  <xsl:choose>
                    <xsl:when test="$type = 'house'"><xsl:text>Maison(s)</xsl:text></xsl:when>
                    <xsl:when test="$type = 'plot'"><xsl:text>Terrain(s)</xsl:text></xsl:when>
                    <xsl:when test="$type = 'buildings'"><xsl:text>Ensemble de bâtiments (biens immeubles)</xsl:text></xsl:when>
                    <xsl:when test="$type = 'territory'"><xsl:text>Domaine, terres, fief</xsl:text></xsl:when>
                    <xsl:when test="$type = 'wall'"><xsl:text>Mur(s)</xsl:text></xsl:when>
                    <xsl:when test="$type = 'cesspool'"><xsl:text>Fosse(s) d'aisance</xsl:text></xsl:when>
                    <xsl:when test="$type = 'well'"><xsl:text>Puits</xsl:text></xsl:when>
                    <xsl:otherwise/>
                  </xsl:choose>
                </sch:let>
                <sch:assert test="$content = $value">Compte tenu du type sélectionné (<sch:value-of select="$type"/>), la valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à "<sch:value-of select="$value"/>".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type">
              <valList type="closed">
                <valItem ident="house"/>
                <valItem ident="plot"/>
                <valItem ident="buildings"/>
                <valItem ident="territory"/>
                <valItem ident="wall"/>
                <valItem ident="cesspool"/>
                <valItem ident="well"/>
                <valItem ident="other"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="objects">
          <gloss>Objects</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="object" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="orgName">
          <gloss>orgName</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="occupation">
          <gloss>Occupation</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="origination">
          <gloss>Origine de l'expertise</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec scheme="schematron" ident="originationValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:origination">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="type" value="@type"/>
                <sch:let name="value">
                  <xsl:choose>
                    <xsl:when test="$type = 'parties'"><xsl:text>Les parties</xsl:text></xsl:when>
                    <xsl:when test="$type = 'institution'"><xsl:text>Une institution</xsl:text></xsl:when>
                    <xsl:otherwise/>
                  </xsl:choose>
                </sch:let>
                <sch:assert test="$content = $value">Compte tenu du type sélectionné (<sch:value-of select="$type"/>), la valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à "<sch:value-of select="$value"/>".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type">
              <valList type="closed">
                <valItem ident="parties"/>
                <valItem ident="institution"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="owner">
          <gloss>Owner</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="parish">
          <gloss>Parish</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="participants">
          <gloss>Participants</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="experts"/>
              <elementRef key="clerks"/>
              <elementRef key="parties"/>
              <elementRef key="craftmen"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="parties">
          <gloss>Parties</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="party" minOccurs="1" maxOccurs="unbounded"/>  
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="party">
          <gloss>Party</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="person" minOccurs="1" maxOccurs="unbounded"/>
              <elementRef key="status"/>
              <elementRef key="expert"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="role" usage="req">
              <valList type="closed">
                <valItem ident="petitioner"/>
                <valItem ident="opponent"/>
              </valList>
            </attDef>
            <attDef ident="presence" usage="req">
              <valList type="closed">
                <valItem ident="true"/>
                <valItem ident="false"/>
              </valList>
            </attDef>
            <attDef ident="intervention">
              <valList type="closed">
                <valItem ident="true"/>
                <valItem ident="false"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="persName">
          <gloss>PersName</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="surname"/>
              <elementRef key="forename"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="person">
          <gloss>Person</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="persName"/>
              <elementRef key="occupation"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="physDesc">
          <gloss>Physical Description</gloss>
          <desc>Physical description of the expertise</desc>
          <content>
            <sequence>
              <elementRef key="extent"/>
              <elementRef key="appendices"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="place">
          <!-- @todo faire schematron en fonction des types ? -->
          <gloss>Place</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="address"/>
              <elementRef key="complement"/>
              <elementRef key="parish"/>
              <elementRef key="city" minOccurs="0" maxOccurs="1"/>
              <elementRef key="district" minOccurs="0" maxOccurs="1"/>
              <elementRef key="owner" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="type">
              <valList type="closed">
                <valItem ident="paris"/>
                <valItem ident="suburbs"/>
                <valItem ident="province"/>
                <valItem ident="office"/>
                <valItem ident="clerkOffice"/>
                <valItem ident="indeterminate"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="places">
          <gloss>Places</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="place" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="procedure">
          <gloss>Procédure</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="framework"/>
              <elementRef key="origination"/>
              <elementRef key="sentences"/>
              <elementRef key="case"/>
              <elementRef key="objects"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="publicationStatus">
          <!-- from EAC -->
          <gloss>Publication Status</gloss>
          <desc>The current publication status of the expertise instance.</desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec ident="publicationStatusValues" scheme="schematron">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:publicationStatus">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="value" value="('inProcess', 'approved')"/>
                <sch:assert test="$content = $value">La valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à : <sch:value-of select="string-join($value, ', ')"/></sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="sentence">
          <gloss>Sentence</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="orgName"/>
              <elementRef key="date" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="sentences">
          <gloss>Sentences</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="sentence" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="sessions">
          <gloss>Sessions</gloss>
          <desc></desc>
          <content>
            <sequence>
              <elementRef key="date" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="sourceDesc">
          <gloss>Source Description</gloss>
          <desc>Contains bibliographic and physical description of an expertise.</desc>
          <content>
            <sequence>
              <elementRef key="unitdate"/>
              <elementRef key="idno" minOccurs="2" maxOccurs="3"/>
              <elementRef key="facsimile"/>
              <elementRef key="physDesc"/>
            </sequence>
          </content>
        </elementSpec>
        
        <elementSpec ident="status">
          <gloss>Status</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec scheme="schematron" ident="statusValues">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:status">
                <sch:let name="node" value="local-name()"/>
                <sch:let name="content" value="normalize-space(.)"/>
                <sch:let name="value" value="('builder', 'owner', 'joint-owner', 'limited-partner', 'heir', 'neighbour', 'tenant', 'main-tenant', 'creditor', 'mortgagor', 'contractor', 'police')">  
                </sch:let>
                <sch:assert test="$content = $value">La valeur de l'élément &lt;<sch:value-of select="$node"/>&gt; doit correspondre à "<sch:value-of select="$value"/>".</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <elementSpec ident="street">
          <gloss>Street</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="surname">
          <gloss>Surname</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="term">
          <!-- from EAC -->
          <gloss>Term</gloss>
          <desc>A generic element used to encode a descriptive term in accordance with local descriptive rules.</desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="title">
          <gloss>Title</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
        </elementSpec>
        
        <elementSpec ident="type">
          <gloss>Type</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <attList>
            <attDef ident="type" usage="req">
              <valList type="closed">
                <valItem ident="drawing"/>
                <valItem ident="plan"/>
                <valItem ident="sketch"/>
                <valItem ident="rough"/>
                <valItem ident="proxyPA"/>
                <valItem ident="proxyNa"/>
                <valItem ident="petition"/>
                <valItem ident="other"/>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        
        <elementSpec ident="unitdate">
          <gloss>Unitdate</gloss>
          <desc></desc>
          <content>
            <textNode/>
          </content>
          <constraintSpec scheme="schematron" ident="unitdateControl">
            <constraint>
              <sch:ns prefix="xpr" uri="xpr"/>
              <sch:rule context="xpr:unitdate">
                <sch:let name="node" value="local-name()"/>
                <sch:assert test="normalize-space(.) castable as xs:gYear">Le contenu de l'élément &lt;<sch:value-of select="$node"/>&gt; doit être de type xs:gYear.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        
        <classSpec type="atts" ident="att.global" module="EAC">
          <desc>provides attributes common to all elements in the EAC encoding
            scheme.</desc>
          <attList>
            <attDef ident="xml:id" usage="opt">
              <gloss>XML identifier</gloss>
              <datatype >
                <dataRef name="ID"></dataRef>
              </datatype>
            </attDef>
            <attDef ident="xml:lang" usage="opt">
              <gloss>XML Language</gloss>
              <datatype>
                <dataRef name="string"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        
        <classSpec type="atts" ident="att.pointer">
          <attList>
            <attDef ident="ref" usage="req">
              <desc/>
              <datatype>
                <dataRef name="anyURI"/>
              </datatype>
            </attDef>
          </attList>
        </classSpec>
        
      </schemaSpec>
    </body>
  </text>
</TEI>
